# 📄 01-requirements.md

## 1. 서비스 개요 & 범위

### 1.1 서비스의 지향점

사용자가 브랜드의 가치를 발견하고, 자신의 취향(좋아요)을 담아, 여러 상품을 한 번에 구매하는 **흐름의 즐거움**을 제공한다.

### 1.2 핵심 흐름

회원가입(1주차 완료) → 상품 탐색 → 좋아요 → 주문

### 1.3 범위

- **핵심 범위:** 상품 탐색, 관심 상품 관리, 주문 생성 및 완료
- **경계 설정:** 주문은 '완료' 단계까지만 책임진다. 환불, 취소, 반품은 이번 범위에 포함하지 않는다.
- **제외:** 결제 연동, 동시성 제어, 장바구니는 이후 고도화 단계에서 다룬다.

### 1.4 액터 정의

이 서비스를 사용하는 사람은 크게 세 종류이다. 누가 무엇을 할 수 있는지를 먼저 정리해야, 이후 기능 정의에서 "이 기능은 누구를 위한 것인가"가 명확해진다.

| 액터 | 식별 방식 | 할 수 있는 일 |
|------|-----------|--------------|
| 비로그인 사용자 | 없음 | 상품 목록 조회, 상품 상세 조회, 브랜드 정보 조회 |
| 로그인 사용자 | `X-Loopers-LoginId` + `X-Loopers-LoginPw` 헤더 | 위 항목 + 좋아요, 주문, 내 정보 관리 |
| 어드민 | `X-Loopers-Ldap: loopers.admin` 헤더 | 브랜드/상품 CRUD, 전체 주문 조회 |

비로그인 사용자도 상품을 둘러보고 브랜드를 확인하는 것은 자유롭게 할 수 있다. "일단 구경부터"가 가능한 서비스를 지향하기 때문이다. 좋아요나 주문처럼 "내 행동을 기록"하는 기능만 로그인을 요구한다.

### 1.5 설계 제약사항

- 인증/인가 자체는 이번 범위에서 구현하지 않는다. 헤더에 담긴 값으로 "이 사람이 누구인지"만 식별한다.
- 결제는 범위 밖이다. 주문 버튼을 누르면 곧바로 구매가 확정되는 것으로 간주한다.
- 고객용 API와 어드민용 API는 URL 체계부터 완전히 분리한다.

---

## 2. 유저 시나리오

- **시나리오 1 (탐색):** 사용자는 특정 브랜드관에 들어가 상품들을 구경하고, 가격이 낮은 순서로 정렬하여 원하는 상품을 찾는다. 품절된 상품도 목록에서 확인할 수 있으며, "품절" 표시가 함께 보인다. 정확한 재고 수량은 보이지 않는다.
- **시나리오 2 (관심):** 마음에 드는 상품의 하트를 누른다. 시스템은 즉시 관심 목록에 추가하고, 인기도(좋아요 수)를 1 올린다. 하트를 한 번 더 누르면 좋아요가 취소되고, 인기도가 1 줄어든다. (사용자에게는 토글로 보이지만, 시스템 내부에서는 등록/취소가 별도 요청으로 분리되어 있다.)
- **시나리오 3 (주문):** 여러 브랜드의 제품들을 한꺼번에 주문한다. 시스템은 모든 상품을 빠짐없이 전수 조사한 뒤, 문제가 있는 상품이 하나라도 있다면 모든 문제를 한 번에 알려준다. 문제가 없다면 주문을 확정한다.
- **시나리오 4 (주문 실패 후 재시도):** 시스템이 "2번 상품은 판매 중지, 4번 상품은 재고 부족(요청 3개, 잔여 1개)"이라고 알려주면, 사용자는 해당 상품들을 빼거나 수량을 조정한 뒤 한 번에 재주문한다.
- **시나리오 5 (주문 내역 확인):** 특정 기간의 주문 내역을 조회하여 과거에 무엇을 주문했는지 확인한다. 주문 완료 후 해당 상품의 가격이 변경되더라도, 주문 내역에는 주문 당시의 정보가 그대로 보인다.

---

## 3. 기능별 동작 규칙

### 3.1 브랜드 & 상품

#### 상품 조회 (고객)

- 전체 상품 목록을 조회하거나, 특정 브랜드의 상품만 필터링할 수 있다. 비로그인 사용자도 조회할 수 있다.
- 목록에서는 상품의 상세 설명을 포함하지 않는다. 상세 설명은 개별 상품 상세 조회에서만 확인할 수 있다.
- 정렬 기준은 최신순(기본값), 가격 낮은순, 인기순(좋아요 수) 세 가지이다.
- 품절 상품(재고 0)은 목록에서 숨기지 않고, "품절" 표시와 함께 노출한다.
- 판매 중지된 상품은 고객 조회 대상에서 제외한다.
- 고객에게는 정확한 재고 수량을 노출하지 않는다. "구매 가능" 또는 "품절"의 이진 상태만 표시한다. 이 결정에 대한 자세한 이유는 정책 22에서 다룬다.

#### 상품 상세 조회 (고객)

- 상품의 상세 정보를 조회한다. 브랜드 정보와 좋아요 수가 함께 반환된다. 비로그인 사용자도 조회할 수 있다.
- 존재하지 않거나 삭제된 상품은 조회할 수 없다.

#### 브랜드 조회 (고객)

- 브랜드 정보를 조회할 수 있다. 비로그인 사용자도 조회할 수 있다.
- 삭제된 브랜드를 조회하면 "존재하지 않음"으로 처리한다.

#### 고객이 보는 정보와 어드민이 보는 정보는 다르다

같은 상품이라도 누가 조회하느냐에 따라 보여주는 범위가 다르다. 고객에게는 구매 결정에 필요한 정보만, 어드민에게는 운영에 필요한 메타데이터까지 포함한다. 예를 들어 정확한 재고 수량, 생성/수정/삭제 일시 같은 정보는 어드민만 볼 수 있다. 이 결정에 대한 상세 내용은 정책 21에서 다룬다.

#### 브랜드/상품 조회 (어드민)

- 어드민은 삭제된 브랜드와 상품을 포함하여 전체 목록을 조회할 수 있다. 고객에게 비노출되는 리소스도 운영 관점에서는 확인이 필요하기 때문이다.
- 개별 브랜드/상품의 상세 조회, 수정, 삭제는 활성 상태의 리소스에만 가능하다. 삭제된 리소스에 접근하면 "존재하지 않음"으로 처리한다.

#### 브랜드 등록 (어드민)

- 활성 브랜드 중 동일한 이름의 브랜드는 등록할 수 없다.
- 단, 삭제된(비활성) 브랜드와 이름이 같은 경우에는 등록을 허용한다 — 과거에 퇴출된 브랜드명을 다시 사용할 수 있어야 하기 때문이다.

#### 상품 등록 (어드민)

- 상품은 이미 등록된 **활성 상태의** 브랜드에만 소속될 수 있다. 삭제된 브랜드에는 상품을 등록할 수 없다.
- 상품 가격은 0 이상의 정수여야 한다. 0원은 프로모션 무료 샘플 등을 위해 허용하지만, 음수는 허용하지 않는다.

#### 상품 수정 (어드민)

- 상품이 속한 브랜드는 한 번 설정되면 수정할 수 없다. 브랜드를 바꾸고 싶다면 기존 상품을 삭제(소프트)하고 새로 등록해야 한다. 이미 생성된 주문 스냅샷의 브랜드 정보가 꼬이지 않도록 하기 위한 정책이다.

#### 브랜드 삭제 (어드민)

- 운영자가 브랜드를 삭제하면, 브랜드 자체는 '삭제됨' 표시만 된다(소프트 삭제). 데이터가 물리적으로 사라지지는 않는다.
- 해당 브랜드에 속한 모든 상품은 자동으로 '판매 중지' 상태로 전환된다. 이 두 작업은 반드시 함께 성공하거나 함께 실패한다 — 브랜드만 삭제되고 상품은 여전히 판매 중인 불일치 상태가 발생하지 않는다.
- 이미 삭제된 브랜드를 다시 삭제하면 "존재하지 않음"으로 처리한다. 삭제된 리소스는 "존재하지 않는 것"으로 간주하기 때문이다.
- 이미 생성된 주문의 스냅샷은 영향받지 않는다.
- 해당 상품의 좋아요 데이터는 삭제하지 않고 유지한다. 대신 좋아요 목록 조회 시 판매 중지 상품을 필터링한다.

#### 상품 삭제 (어드민)

- 소프트 삭제를 적용한다. 이미 삭제된 상품을 다시 삭제하면 "존재하지 않음"으로 처리한다.
- 해당 상품의 좋아요 데이터는 삭제하지 않고, 조회 시 필터링으로 처리한다.
- 기존 주문 스냅샷에는 영향이 없다.

---

### 3.2 좋아요

#### 좋아요 등록

- 사용자가 상품에 좋아요를 등록하면, 해당 상품의 인기도(좋아요 수)가 1 증가한다.
- 판매 중지된 상품에는 새로운 좋아요를 등록할 수 없다. 삭제된 상품도 마찬가지이다.
- 이미 좋아요한 상품에 다시 좋아요 요청이 오면 "이미 등록된 상태"임을 알린다. 사용자 화면에서는 하트가 토글로 동작하지만, 시스템 내부에서는 등록과 취소가 별도 요청이기 때문이다. 이 결정에 대한 자세한 이유는 정책 13에서 다룬다.

#### 좋아요 취소

- 좋아요를 취소하면 인기도가 1 감소하고, 좋아요 데이터는 즉시 삭제된다.
- 좋아요가 없는 상태에서 취소 요청이 오면 "존재하지 않음"으로 처리한다.

#### 좋아요 목록 조회

- 사용자는 자신이 좋아요 한 상품 목록을 조회할 수 있다. 다른 사용자의 좋아요 목록에는 접근할 수 없다.
- 삭제되거나 판매 중지된 상품은 좋아요 목록에서 제외한다. 좋아요 데이터 자체는 유지되지만, 사용자에게 보여줄 때 걸러낸다. 이렇게 하면 나중에 상품이 다시 판매 재개될 경우 좋아요가 자연스럽게 복원된다.

#### 인기도 반영

- 인기도(좋아요 수)는 좋아요 등록/취소 시 즉시 반영한다.

---

### 3.3 주문

#### 주문 생성 로직

주문 로직의 핵심 원칙은 **'전수 조사 후 일괄 응답'** 과 **'확인과 확정의 분리'** 이다.

**1단계 — 요청 형식 검증**

- 주문 항목이 비어있지 않은지 확인한다.
- 수량이 1개 미만인 항목이 포함되어 있으면 거부한다.
- 같은 상품이 여러 줄에 걸쳐 중복으로 들어오면 거부한다. (→ 정책 4)
- 한 번에 주문할 수 있는 상품 종류와 수량이 상한을 넘지 않는지 확인한다. (→ 정책 5)

**2단계 — 상품 상태 전수 조사**

- 존재하지 않는 상품이 포함되어 있는지 확인한다.
- 판매 중지된 상품이 포함되어 있는지 확인한다.
- 문제가 발견되면 **바로 멈추지 않고**, 오류 목록에 기록한 뒤 다음 상품 검사를 계속한다.

**3단계 — 재고 전수 조사**

- 각 상품별로 요청 수량 대비 현재 재고가 충분한지 확인한다.
- 부족한 경우 "요청 N개, 잔여 M개" 형태로 오류 목록에 기록한다.

**4단계 — 오류 판정**

- 2~3단계에서 수집된 오류가 **하나라도** 있으면 → 주문 전체를 반려하고, 오류 목록을 일괄 반환한다. 각 상품별로 무엇이 왜 문제인지 구체적으로 알려준다.
- 오류가 없으면 → 5단계로 진행한다.

**5단계 — 확정 (이 단계에서만 데이터를 변경한다)**

- 각 상품의 재고를 주문 수량만큼 줄인다.
- 주문 시점의 정보를 복사하여 스냅샷을 생성한다. 스냅샷에는 "내가 뭘, 얼마에, 어디서 샀는지" 인지할 수 있는 최소 정보(상품명, 단가, 수량, 브랜드명, 이미지)만 포함한다.
- 주문 총 금액은 서버에서 계산한다. 클라이언트가 보낸 금액은 신뢰하지 않는다 — 상품 ID와 수량만 받는다.
- 주문 상태를 '완료'로 기록하고 사용자에게 성공을 알린다.
- 재고 차감, 스냅샷 생성, 주문 기록은 반드시 함께 처리된다 — 셋 중 하나라도 실패하면 전부 원래대로 돌아간다.

> **왜 확인과 확정을 분리했는가?** 1~4단계에서는 데이터를 읽기만 하고, 5단계에서만 데이터를 변경한다. 이렇게 나누면 두 가지 이점이 있다. 첫째, 검증 도중에 실수로 재고가 차감되는 사고를 원천적으로 방지할 수 있다. 둘째, 나중에 여러 사용자가 동시에 주문하는 상황을 해결할 때, "제어가 필요한 구간"을 5단계로 한정할 수 있어 구조가 깔끔해진다.

#### 주문 상태

현재는 '완료(COMPLETED)' 하나만 존재한다. 이후 결제 기능이 추가되면 '결제 대기', '결제 완료', '취소' 등으로 확장할 예정이다. 지금부터 상태 필드를 두는 이유는, 나중에 상태가 늘어나도 기존 구조를 바꾸지 않아도 되기 때문이다.

#### 주문 목록 조회 (고객)

- 사용자는 자신의 주문 내역을 기간별로 조회할 수 있다.
- 조회 기간(시작일, 종료일)은 필수이다. 기간을 지정하지 않으면 요청을 거부한다. "기본값 3개월" 같은 암묵적인 조건 대신, 클라이언트가 항상 의도를 명시하도록 강제한다.
- 각 주문의 요약 정보(주문일, 총 금액, 상품 수, 상태)를 반환한다.
- 타 유저의 주문은 조회할 수 없다.

#### 주문 상세 조회 (고객)

- 특정 주문의 상세 내역을 스냅샷 데이터 기반으로 조회한다. 현재 상품 정보가 아니라 구매 당시 정보가 표시된다.
- 본인의 주문만 조회할 수 있다.

#### 주문 조회 (어드민)

- 전체 주문 목록을 페이지네이션으로 조회할 수 있다.
- 주문 상세 조회 시 주문자 정보를 포함하여 반환한다.

---

## 4. 도메인 간 영향 관계

어떤 도메인에서 변경이 일어나면 다른 도메인에 어떤 영향을 미치는지를 한 눈에 볼 수 있는 표이다. "브랜드를 삭제하면 주문은 어떻게 되지?" 같은 질문에 이 표를 참고하면 된다.

| 이벤트 | Brand | Product | Like | Order/OrderItem |
|--------|-------|---------|------|-----------------|
| 브랜드 삭제 | soft delete | 연쇄 판매 중지 | 조회 시 필터링 (데이터 유지) | 영향 없음 (스냅샷 보존) |
| 상품 삭제 | 영향 없음 | soft delete | 조회 시 필터링 (데이터 유지) | 영향 없음 (스냅샷 보존) |
| 상품 가격 변경 | 영향 없음 | price 업데이트 | 영향 없음 | 영향 없음 (스냅샷 보존) |
| 유저 탈퇴 | 영향 없음 | 영향 없음 | 해당 유저 좋아요 삭제 | 주문 내역 보존 (정책 16) |

---

## 5. 정책 결정 및 트레이드오프

### 🛒 주문

#### 정책 1. 전체 반려(Atomic Failure) vs 부분 주문 성공

**어떤 상황인가:** 사용자가 5개 상품을 주문했는데 그중 1개의 재고가 없다. 나머지 4개만이라도 주문을 진행할 것인가?

| 관점 | 부분 진행 | 전체 반려 |
|------|-----------|-----------|
| 사용자 경험 | 일부라도 주문이 진행되어 편리하다 | 전부 실패하므로 다시 주문해야 한다 |
| 후속 처리 | "3개는 배송, 2개는 취소" 같은 복잡한 처리가 필요하다 | 성공 아니면 실패, 추가 로직이 없다 |
| 데이터 정합성 | 주문 금액과 실제 배송 항목이 어긋날 수 있다 | 주문 내용과 금액이 항상 일치한다 |
| 시스템 복잡도 | 높다 (부분 상태 관리, 환불 로직 필수) | 낮다 |

**결정: 전체 반려.**

**왜 이렇게 결정했는가:** 현재 이 서비스에는 취소나 환불 기능이 없다. 부분 진행을 허용하면, "3개는 배송되고 2개는 취소해야 하는데 취소할 방법이 없는" 상황이 생긴다. 시스템 안정성과 데이터 무결성을 우선했다.

**대신 이렇게 보완한다:** 전수 조사(정책 2)를 통해 모든 문제를 한 번에 알려줌으로써, "왜 실패했는지 모르겠다"는 불만을 줄인다.

**향후:** 취소/환불 기능이 생기면, "문제 상품을 제외하고 계속 진행하시겠습니까?" 같은 선택지를 제공할 수 있다.

---

#### 정책 2. 즉시 중단(Fail-Fast) vs 전수 조사(Batch Validation)

**어떤 상황인가:** 주문 검증 중 문제가 발견되었을 때, 그 즉시 멈출 것인가 나머지도 다 검사할 것인가?

| 관점 | 즉시 중단 | 전수 조사 |
|------|-----------|-----------|
| 사용자 경험 | 오류를 하나씩 알려준다 → "고치고 재시도"를 반복해야 한다 | 모든 오류를 한 번에 알려준다 → 한 번에 수정할 수 있다 |
| 재주문 시도 횟수 | 문제 상품이 3개면 최대 3번 시도해야 한다 | 1번이면 충분하다 |
| 시스템 비용 | 문제를 발견하면 바로 끝나므로 리소스를 아낄 수 있다 | 모든 상품을 조회해야 한다 |

**결정: 전수 조사.**

**왜 이렇게 결정했는가:** 정책 1에서 "전체 반려"를 택했으므로, 주문이 실패할 때 사용자가 느끼는 불편함을 최소화해야 한다. "2번 상품은 판매 중지, 4번 상품은 재고 부족"을 한 번에 알려주면, 사용자는 한 번의 수정으로 재주문을 마칠 수 있다.

즉시 중단 방식에서는 "2번 상품 판매 중지"를 해결하고 다시 주문했는데 이번엔 "4번 상품 재고 부족"이 나올 수 있다. 그 사이에 다른 상품마저 품절될 위험도 있다.

---

#### 정책 3. 스냅샷 전략 — 과거 정보를 어떻게 보존할 것인가

**어떤 상황인가:** 사용자가 1만 원짜리 상품을 주문한 뒤, 어드민이 그 상품의 가격을 2만 원으로 올렸다. 주문 내역에 찍힌 가격은 1만 원이어야 하는가, 2만 원이어야 하는가?

| 관점 | 실시간 참조 (항상 최신 정보를 보여줌) | 정보 복사 (스냅샷) |
|------|--------------------------------------|-------------------|
| 사용자 신뢰 | "1만 원에 샀는데 왜 2만 원이라고 나오지?" → 혼란 | 구매 시점 가격이 영구 보존된다 |
| 법적 측면 | 거래 기록 증명이 어렵다 | 거래 당시의 계약 조건을 그대로 보존한다 |
| 저장 공간 | 적다 | 주문마다 복사본이 생긴다 |

**결정: 스냅샷.**

**왜 이렇게 결정했는가:** 거래 기록은 일종의 계약서이다. "내가 뭘, 얼마에, 어디서 샀는지"가 나중에 바뀌면 안 된다. 저장 공간이 조금 더 드는 것은 감수할 만한 트레이드오프이다.

**스냅샷에 포함하는 정보:** 상품명, 단가(구매 시점), 주문 수량, 브랜드명, 상품 이미지. 상세 설명이나 카테고리 같은 정보는 포함하지 않는다.

---

#### 정책 4. 동일 상품 중복 주문 요청

**어떤 상황인가:** 한 주문에 같은 상품이 두 줄로 들어오면?

| 관점 | 자동 합산 | 요청 거부 |
|------|-----------|-----------|
| 편의성 | 시스템이 알아서 처리해준다 | 사용자가 직접 수정해야 한다 |
| 의도 명확성 | "실수인지 의도인지" 시스템이 판단할 수 없다 | 요청의 의미가 항상 명확하다 |

**결정: 요청 거부.**

**왜 이렇게 결정했는가:** 시스템이 사용자의 의도를 추론하는 것보다, 요청 자체가 명확한 것이 장기적으로 안전하다.

---

#### 정책 5. 주문 수량/종류 상한

**어떤 상황인가:** 한 상품을 10,000개 주문하거나, 한 주문에 상품을 100종류 담는 것을 허용할 것인가?

| 제한 항목 | 상한 | 이유 |
|-----------|------|------|
| 1회 주문당 상품 종류 | 최대 20종 | 일반적인 온라인 쇼핑 패턴 기준 |
| 상품당 주문 수량 | 최대 99개 | 대량 구매는 별도 채널(B2B)로 안내 |

이 수치는 운영 데이터를 보면서 조정할 수 있다.

---

#### 정책 6. 주문 목록 조회 기간

**어떤 상황인가:** 사용자가 기간을 지정하지 않거나, 1년치 주문을 한 번에 요청하면?

| 관점 | 기본값 제공 (예: 최근 3개월) | 필수 파라미터 |
|------|---------------------------|--------------|
| 사용자 편의 | 기간 없이 바로 조회할 수 있다 | 반드시 기간을 지정해야 한다 |
| 시스템 안전 | 기본값이 예상 외로 넓어 대량 조회가 발생할 수 있다 | 의도치 않은 대량 조회를 원천 차단한다 |
| 클라이언트 책임 | 기본값에 의존하여 의도가 불분명할 수 있다 | 항상 명시적으로 의도를 표현한다 |

**결정: 필수 파라미터.**

**왜 이렇게 결정했는가:** 기간을 반드시 지정해야 한다. 기본값을 두면 클라이언트가 "아무 생각 없이" 전체 조회를 할 수 있고, 이는 시스템 부하로 이어진다.

---

#### 정책 7. 0원 상품(무료 상품) 주문

**결정: 가능.**

**왜 이렇게 결정했는가:** 0원 상품도 재고 관리 대상이며, 주문 프로세스를 동일하게 적용한다. 프로모션용 무료 샘플 등 비즈니스 시나리오는 충분히 있고, 별도 예외 처리를 두면 오히려 시스템이 복잡해진다.

---

#### 정책 8. 가격 변경과 주문 사이의 시간차

**어떤 상황인가:** 사용자가 상품 목록에서 1만 원을 보고 주문 버튼을 눌렀는데, 그 사이에 가격이 1.5만 원으로 바뀌었다면?

**결정:** 주문 확정 시점의 가격이 곧 확정 가격이다. 스냅샷에도 이 가격이 기록된다.

**향후:** 주문 확인 화면에서 최신 가격을 다시 보여주고 동의를 받는 UX를 추가할 수 있다.

---

### 🏷 브랜드 & 상품

#### 정책 9. 브랜드/상품 삭제 방식 — 즉시 제거 vs 삭제 표시

**어떤 상황인가:** 운영자가 브랜드나 상품을 "삭제"했을 때, 데이터를 물리적으로 지울 것인가?

| 관점 | 즉시 제거 (하드 삭제) | 삭제 표시 (소프트 삭제) |
|------|----------------------|----------------------|
| 운영 안전성 | 실수로 삭제하면 복구가 불가능하다 | 실수로 삭제해도 데이터가 남아있다 |
| 데이터 분석 | 삭제된 이력을 추적할 수 없다 | "어떤 브랜드가 언제 퇴출됐는지" 분석할 수 있다 |
| 확장성 | "과거 상품 보기" 같은 기능을 만들 수 없다 | 향후 기능 확장에 유리하다 |

**결정: 소프트 삭제.**

**왜 이렇게 결정했는가:** 이커머스에서 데이터는 자산이다. 실수 복구, 운영 이력 추적, 향후 확장을 모두 고려하면 소프트 삭제가 합리적이다.

---

#### 정책 10. 품절 상품(재고 0) 노출 여부

**어떤 상황인가:** 재고가 0인 상품을 목록에서 숨길 것인가?

| 관점 | 목록에서 숨김 | 노출 + 품절 표시 |
|------|-------------|-----------------|
| 사용자 경험 | 살 수 있는 상품만 보여서 깔끔하다 | 브랜드의 전체 라인업을 탐색할 수 있다 |
| 브랜드 가치 | 인기 상품이 갑자기 사라지면 브랜드 매력이 줄어든다 | "이 상품은 인기가 많아서 품절됐구나"라는 사회적 증거가 된다 |

**결정: 노출 + 품절 표시.**

**왜 이렇게 결정했는가:** 감성 이커머스 특성상 "구경"하는 행위 자체에 가치가 있다. 품절 상품을 숨기면 브랜드관이 빈약해 보일 수 있다. 주문은 검증 단계에서 자연스럽게 걸러진다.

---

#### 정책 11. 상품 브랜드 변경 불가

**결정:** 상품이 속한 브랜드는 한 번 설정되면 수정할 수 없다. 브랜드를 바꾸고 싶다면 기존 상품을 삭제(소프트)하고 새 브랜드 아래 새 상품을 등록한다.

**왜 이렇게 결정했는가:** 이미 생성된 주문 스냅샷에 "브랜드 A의 상품"이라고 기록되어 있는데, 원본 상품의 브랜드를 B로 바꾸면 데이터 일관성에 혼란이 생긴다.

---

### ❤️ 좋아요

#### 정책 12. 좋아요 취소 시 데이터 처리

**어떤 상황인가:** 좋아요를 취소했을 때, "취소됨" 상태로 남길 것인가 기록을 아예 지울 것인가?

**결정: 즉시 삭제 (하드 삭제).**

**왜 이렇게 결정했는가:** 좋아요는 주문과 달리 법적 보존 의무가 없으며, 등록과 취소가 매우 빈번하게 일어난다. 취소할 때마다 "취소됨" 레코드를 남기면 데이터가 불필요하게 쌓인다.

**단, 예외가 하나 있다:** 브랜드나 상품이 삭제(소프트)될 때는 해당 상품의 좋아요 데이터를 함께 지우지 않는다. 대신 좋아요 목록 조회 시 필터링으로 처리한다. 이렇게 하면 나중에 상품이 복구될 경우 좋아요도 자연스럽게 살아난다.

---

#### 정책 13. 좋아요 중복 요청 — 이미 좋아요한 상품에 또 좋아요하면?

| 관점 | 에러 반환 (명시적 알림) | 멱등성 보장 (조용히 성공) |
|------|----------------------|-------------------------|
| 의미 | "이미 좋아요 상태입니다"라고 명확히 알려준다 | 같은 요청을 여러 번 보내도 결과가 동일하다 |
| 디버깅 | 클라이언트 상태 불일치(버그)를 빠르게 발견할 수 있다 | 실제 오류와 중복 요청을 구분하기 어렵다 |
| 적합한 상황 | 등록/취소가 별도 요청으로 분리된 구조 | 하트 토글처럼 하나의 요청으로 처리하는 구조 |

**결정: 에러 반환 (409 Conflict).**

**왜 이렇게 결정했는가:** 좋아요 등록과 취소를 별도 요청으로 분리했으므로, 클라이언트는 "지금 이 사용자가 좋아요 상태인지 아닌지"를 알고 있는 상태에서 요청을 보낸다. 이미 좋아요 상태에서 또 등록을 시도하는 것은 클라이언트의 상태 관리에 문제가 있다는 신호이다. 이를 조용히 넘기면 버그를 감추게 된다.

좋아요 취소도 동일하게, 좋아요가 없는 상태에서 취소를 시도하면 "존재하지 않음"으로 처리한다.

---

#### 정책 14. 판매 중지/삭제된 상품의 기존 좋아요

**어떤 상황인가:** 사용자가 좋아요를 누른 상품이 이후에 판매 중지되거나 삭제되면, 좋아요 목록에서 어떻게 보여야 하는가?

| 관점 | 좋아요 자동 삭제 | 데이터 유지 + 조회 시 필터링 |
|------|-----------------|--------------------------|
| 사용자 경험 | 관심 목록에서 갑자기 사라진다 | 판매 재개되면 다시 자연스럽게 보인다 |
| 시스템 처리 | 상품 삭제 시 대량 삭제가 필요하다 | 조회할 때 조건 하나만 추가하면 된다 |
| 데이터 일관성 | 인기도 재계산이 필요하다 | 인기도 변경 없음 |

**결정: 데이터 유지 + 조회 시 필터링.**

**왜 이렇게 결정했는가:** 브랜드 삭제 시 수천 개의 좋아요를 한꺼번에 지우는 것보다, 조회할 때 "이 상품이 아직 유효한가?"를 확인하는 것이 더 안전하고 유연하다. 상품이 다시 판매를 재개하면 좋아요가 별도 작업 없이 자동으로 복원된다.

---

#### 정책 15. 인기도(좋아요 수) 정합성

**결정:** 인기도는 좋아요 등록/취소 시 즉시 반영한다.

**왜 이렇게 결정했는가:** "인기순 정렬"은 사용자가 자주 쓰는 기능이다. 인기도가 실시간으로 반영되어야 정렬 결과가 신뢰할 수 있다.

**향후:** 여러 사용자가 동시에 좋아요를 누를 때 수치가 어긋나는 문제는 고도화 단계에서 해결한다.

---

### 👤 유저 (영향 범위 명시)

#### 정책 16. 탈퇴한 유저의 데이터 처리

회원 탈퇴는 현재 범위에 포함하지 않는다. 향후 추가될 경우의 원칙만 명시한다.

- **주문 내역:** 법적 보관 의무 기간 동안 보존한다. 유저 식별 정보만 마스킹한다.
- **좋아요 기록:** 탈퇴 시 삭제한다. 해당 상품의 인기도도 재계산한다.

---

### 🔧 어드민

#### 정책 17. 어드민 조작과 사용자 활동의 동시성

운영자가 상품 가격이나 재고를 수정하는 중에 사용자 주문이 들어오는 동시성 문제는 인지하되, 이후 고도화 단계에서 해결한다. 현재 주문 로직의 "확인과 확정 분리" 구조가 향후 동시 접근 제어의 구조적 기반이 된다.

#### 정책 18. 어드민 주문 조회

현재는 페이지네이션만 제공한다. 기간 필터, 주문 상태 필터, 사용자별 필터는 운영 필요에 따라 확장한다.

---

### 🔐 인증 & 접근 제어

#### 정책 19. 어드민 인증 방식 — 왜 고객과 분리하는가

| 관점 | 동일한 인증 체계 | 분리된 인증 체계 |
|------|----------------|----------------|
| 보안 | 고객 계정이 탈취되면 운영 권한까지 위험해진다 | 운영 권한은 완전히 다른 경로로만 접근할 수 있다 |
| URL 설계 | 같은 URL에서 권한을 분기해야 해서 복잡하다 | 고객용과 어드민용이 명확히 나뉜다 |
| 운영 안정성 | 고객 트래픽 급증이 어드민에 영향을 줄 수 있다 | 독립적으로 운영할 수 있다 |

**결정: 분리된 인증 체계.**

**왜 이렇게 결정했는가:** 고객과 어드민은 하는 일이 완전히 다르다. 인증 방식부터 URL 체계까지 분리하면, 실수로 고객 경로에서 어드민 기능에 접근하는 사고를 원천적으로 막을 수 있다.

---

#### 정책 20. 타 유저 데이터 접근 제어

**어떤 상황인가:** 사용자가 URL에 다른 사람의 식별자를 넣어서 그 사람의 좋아요 목록이나 주문 내역을 보려고 시도하면?

**결정: 접근 차단 (403 Forbidden).**

**왜 이렇게 결정했는가:** "유저는 타 유저의 정보에 직접 접근할 수 없다"는 기본 원칙을 시스템 레벨에서 강제한다.

---

### 📋 공통

#### 정책 21. 고객 vs 어드민 정보 노출 범위

**어떤 상황인가:** 같은 상품 데이터를 고객과 어드민에게 어디까지 보여줄 것인가?

**결정:** 고객에게는 구매 결정에 필요한 비즈니스 정보만 보여준다. 어드민에게는 운영에 필요한 메타데이터(정확한 재고 수량, 생성/수정/삭제 일시, 상태 등)까지 포함한다.

**왜 이렇게 결정했는가:** 고객에게 불필요한 내부 정보를 노출하면 보안 리스크이자 UX 혼란이다. 어드민에게는 운영 의사결정에 필요한 모든 정보를 제공한다.

---

#### 정책 22. 재고 표시 방식 (고객)

**어떤 상황인가:** 고객에게 "3개 남았습니다"처럼 정확한 재고 수량을 보여줄 것인가?

| 관점 | 정확한 수량 노출 | "구매 가능 / 품절" 이진 표시 |
|------|-----------------|----------------------------|
| 사용자 심리 | "3개 남음!" 같은 표시가 긴박감을 유발하여 충동 구매를 유도할 수 있다 | 단순하고 명확하다 |
| 어뷰징 리스크 | 재고 수량을 보고 전량 사재기하는 행위가 가능하다 | 정확한 수량을 알 수 없어 사재기를 방지한다 |

**결정: "구매 가능 / 품절" 이진 표시만.**

**왜 이렇게 결정했는가:** 재고 수량은 내부 운영 정보이다. 감성 이커머스에서 "남은 3개를 전부 사재기" 같은 행위를 방지하고, 사용자에게는 "살 수 있는가, 없는가"라는 핵심 정보만 전달한다.

---

#### 정책 23. 브랜드명 중복 허용 여부

**어떤 상황인가:** 같은 이름의 브랜드가 두 개 존재할 수 있는가?

| 관점 | 허용 | 불허 |
|------|------|------|
| 유연성 | 동명의 다른 브랜드를 등록할 수 있다 | 이름으로 브랜드를 고유하게 식별할 수 있다 |
| 사용자 혼란 | "어떤 나이키지?" → 구분이 안 된다 | 혼란이 없다 |

**결정: 활성 브랜드 기준 불허 (409 Conflict).**

**왜 이렇게 결정했는가:** 동일한 이름의 브랜드가 존재하면 사용자가 혼란을 겪는다. 단, 삭제된(비활성) 브랜드와 이름이 같은 경우에는 허용한다 — 과거에 퇴출된 브랜드명을 새 브랜드가 사용할 수 있어야 한다.

---

#### 정책 24. 삭제된 브랜드에 상품 등록

**어떤 상황인가:** 이미 삭제된 브랜드 아래에 새 상품을 만들 수 있는가?

**결정: 불가 (400 Bad Request).**

**왜 이렇게 결정했는가:** 삭제된 브랜드는 서비스에서 유효하지 않다. 유효하지 않은 브랜드 아래 상품을 등록하는 것은 논리적 모순이다.

---

#### 정책 25. 이미 삭제된 리소스 재삭제

**어떤 상황인가:** 이미 소프트 삭제된 브랜드나 상품에 다시 삭제 요청이 오면?

| 관점 | 멱등 처리 (성공 응답) | "존재하지 않음" 처리 (404) |
|------|---------------------|--------------------------|
| 일관성 | "삭제했다"는 결과는 같으므로 자연스럽다 | "존재하지 않는 리소스"라는 원칙에 충실하다 |
| 클라이언트 인지 | 이미 삭제된 건지 방금 삭제된 건지 알 수 없다 | 명확한 상태 피드백을 준다 |

**결정: "존재하지 않음" 처리 (404 Not Found).**

**왜 이렇게 결정했는가:** 소프트 삭제된 리소스는 "존재하지 않는 것"으로 간주한다. 고객 화면에서도, 어드민의 개별 조회/수정/삭제에서도 동일하게 처리하여 일관성을 유지한다. 다만 어드민의 목록 조회에서는 "삭제됨" 상태로 확인할 수 있다.

---

#### 정책 26. 상품 정렬 기본값

**결정: 최신순 (latest).**

**왜 이렇게 결정했는가:** 새로 등록된 상품을 우선 노출하여 "새로운 발견"의 경험을 제공한다. 감성 이커머스에서 "뭐가 새로 나왔지?"라는 탐색이 자연스러운 시작점이다.

---

#### 정책 27. 페이지네이션 기본값

**결정: page=0, size=20.**

**왜 이렇게 결정했는가:** 모든 페이지네이션이 필요한 기능에서 동일한 기본값을 사용하여 일관성을 유지한다.

---

#### 정책 28. 주문 금액 계산 주체

**어떤 상황인가:** 주문 총 금액을 클라이언트가 보내는 값을 쓸 것인가, 서버에서 계산할 것인가?

| 관점 | 클라이언트 전송 | 서버 계산 |
|------|----------------|----------|
| 보안 | 금액을 조작할 수 있다 | 조작이 불가능하다 |
| 불일치 처리 | 서버-클라이언트 금액이 다를 때의 처리가 필요하다 | 서버가 유일한 출처이므로 항상 정확하다 |

**결정: 서버에서 계산.**

**왜 이렇게 결정했는가:** 클라이언트는 상품 ID와 수량만 보내고, 금액은 서버가 해당 상품의 현재 가격을 조회하여 직접 계산한다. 금액 조작을 원천 차단한다.

---

#### 정책 29. 상품 가격 규칙

**결정: 원 단위 정수, 0 이상.**

**왜 이렇게 결정했는가:** 한국 원화 기반 서비스에서 소수점 금액은 불필요하다. 0원은 프로모션 무료 샘플 등을 위해 허용하고(정책 7과 연동), 음수는 허용하지 않는다.

---

#### 정책 30. PK(식별자) 전략

**어떤 상황인가:** 모든 테이블의 PK를 AUTO_INCREMENT로 할 것인가, Snowflake/UUID 같은 분산 ID를 쓸 것인가?

| 관점 | AUTO_INCREMENT | Snowflake / UUID |
|------|---------------|-----------------|
| 성능 | 순차 삽입으로 B-tree 효율 최적 | UUID는 랜덤 삽입으로 인덱스 성능 저하, Snowflake는 순차적이라 양호 |
| 분산 환경 | 단일 DB에서만 유효, 다중 DB 시 충돌 | 다중 인스턴스에서도 고유 ID 보장 |
| 정보 노출 | 순차적이므로 전체 건수 추측 가능 | 추측 불가 |
| 구현 복잡도 | DB 기본 기능, 추가 구현 없음 | Snowflake 생성기 또는 UUID 라이브러리 필요 |

**결정: AUTO_INCREMENT.**

**왜 이렇게 결정했는가:** 현재 단일 MySQL 인스턴스 환경이며, 분산 ID가 필요한 시점이 아니다. 순차 ID의 정보 노출 문제는 인증/인가(정책 19, 20)로 방어한다 — 타인의 ID를 알더라도 접근 자체가 차단된다. PK 자체를 숨기는 것보다 접근 제어를 확실히 하는 것이 본질적인 해결이다.

**향후:** DB 인스턴스가 분리되거나 MSA로 전환될 경우, Snowflake 기반 ID 생성기를 도입한다. AUTO_INCREMENT와 동일하게 bigint이므로 스키마 변경 없이 생성 방식만 교체 가능하다.

---

#### 정책 31. 주문 번호(외부 식별자)

**어떤 상황인가:** 주문에 내부 PK 외에 사용자에게 노출하는 별도 주문 번호(`ORD-20260213-0001` 등)가 필요한가?

**결정: 현재 범위에서는 도입하지 않는다.**

**왜 이렇게 결정했는가:** 주문 번호는 CS 응대, 주문 확인 메일, 결제 연동 등에서 사용되는데, 현재 범위에 이 기능들이 없다. 사용처 없이 컬럼만 존재하면 불필요한 복잡도가 된다.

**향후:** 결제 연동이나 주문 알림 기능이 추가될 때, `orders` 테이블에 `order_number` 컬럼을 추가한다. Snowflake 기반 또는 날짜+시퀀스 형식(`ORD-YYYYMMDD-NNNN`)을 고려한다.

---

## 6. 정책 결정 상태 요약

| # | 정책 | 결정 | 상태 |
|---|------|------|------|
| 1 | 전체 반려 vs 부분 성공 | 전체 반려 + 오류 목록 일괄 반환 | ✅ |
| 2 | 즉시 중단 vs 전수 조사 | 전수 조사 | ✅ |
| 3 | 스냅샷 전략 | 주문 시점 정보 복사 | ✅ |
| 4 | 동일 상품 중복 주문 | 요청 거부 | ✅ |
| 5 | 주문 수량/종류 상한 | 20종 / 99개 | ✅ |
| 6 | 주문 조회 기간 | 필수 파라미터 | ✅ |
| 7 | 0원 상품 주문 | 가능 (가격 >= 0) | ✅ |
| 8 | 가격 변경과 주문 시차 | 확정 시점 가격 적용 | ✅ |
| 9 | 브랜드/상품 삭제 방식 | 소프트 삭제 | ✅ |
| 10 | 품절 상품 노출 | 노출 + 품절 표시 | ✅ |
| 11 | 상품 브랜드 변경 불가 | 삭제 후 재등록 | ✅ |
| 12 | 좋아요 취소 시 제거 | 하드 삭제 (단, 상품 삭제 시 좋아요 유지) | ✅ |
| 13 | 좋아요 중복 요청 | 409 Conflict | ✅ |
| 14 | 판매 중지 상품의 좋아요 | 데이터 유지 + 조회 시 필터링 | ✅ |
| 15 | 인기도 정합성 | 실시간 반영 | ✅ |
| 16 | 탈퇴 유저 데이터 | 원칙만 명시 | 📌 범위 외 |
| 17 | 어드민-사용자 동시성 | 이후 고도화 | 📌 위임 |
| 18 | 어드민 주문 필터링 | 페이지네이션만 | 📌 최소 구현 |
| 19 | 어드민 인증 방식 | 고객과 분리 | ✅ |
| 20 | 타 유저 접근 제어 | 403 Forbidden | ✅ |
| 21 | 고객/어드민 정보 노출 범위 | 어드민=메타데이터 포함 | ✅ |
| 22 | 재고 표시 방식 | 고객에게 이진 표시 | ✅ |
| 23 | 브랜드명 중복 | 활성 기준 불허 → 409 | ✅ |
| 24 | 삭제된 브랜드에 상품 등록 | 불가 → 400 | ✅ |
| 25 | 삭제된 리소스 재삭제 | 404 Not Found | ✅ |
| 26 | 상품 정렬 기본값 | 최신순 (latest) | ✅ |
| 27 | 페이지네이션 기본값 | page=0, size=20 | ✅ |
| 28 | 주문 금액 계산 주체 | 서버에서 계산 | ✅ |
| 29 | 상품 가격 규칙 | 원 단위 정수, 0 이상 | ✅ |
| 30 | PK 식별자 전략 | AUTO_INCREMENT (향후 Snowflake) | ✅ |
| 31 | 주문 번호(외부 식별자) | 현재 미도입 (향후 결제 연동 시) | 📌 범위 외 |

---

## 7. 도메인 용어 사전

| 용어 | 영문 | 정의 |
|------|------|------|
| 브랜드 | Brand | 상품을 공급하는 브랜드 |
| 상품 | Product | 브랜드에 속한 판매 상품 |
| 재고 | Stock | 현재 시스템에서 즉시 구매할 수 있는 물건의 개수 |
| 좋아요 | Like | 사용자가 관심 상품에 표시하는 행위 |
| 인기도 | Popularity | 상품이 받은 전체 좋아요의 총합 |
| 주문 | Order | 사용자의 구매 요청 단위 |
| 주문 항목 | OrderItem | 주문에 포함된 개별 상품 정보 (스냅샷) |
| 주문 완료 | Completed | 재고 확인과 차감이 모두 끝나고 거래가 기록된 상태 |
| 판매 중지 | Deactivated | 상품 정보는 남아있으나 구매/좋아요 불가. 기존 좋아요는 유지 |
| 스냅샷 | Snapshot | 주문 확정 시점의 상품 정보를 복사한 것. 원본 변경에 무영향 |
| 전수 조사 | Batch Validation | 주문 내 모든 상품을 빠짐없이 검사하여 문제를 한 번에 수집하는 방식 |
| 전체 반려 | Atomic Failure | 하나라도 문제가 있으면 주문 전체를 거부하는 정책 |
| 소프트 삭제 | Soft Delete | 실제로 지우지 않고 '삭제됨' 표시를 남기는 방식. 고객에게는 비노출 |
| 하드 삭제 | Hard Delete | 데이터를 물리적으로 완전히 삭제하는 방식 |
| 반정규화 | Denormalization | 조회 성능을 위해 집계값을 별도로 저장해두는 기법 |
| 멱등성 | Idempotency | 같은 요청을 여러 번 보내도 결과가 한 번 보낸 것과 동일한 성질 |